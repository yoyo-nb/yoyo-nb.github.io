<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YOYO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-02T14:37:25.766Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yoyo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【杂谈】2020届北航计算机，清华软件保研经验</title>
    <link href="http://yoursite.com/post/39d6c6d8.html"/>
    <id>http://yoursite.com/post/39d6c6d8.html</id>
    <published>2020-04-01T08:25:00.000Z</published>
    <updated>2020-04-02T14:37:25.766Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/by.jpg" alt="封面"></p><p>本人定位：</p><ul><li>学校：吉林大学</li><li>排名：由于学校排名方式有变化，所以夏令营时期的排名是30/351，预推免时期的排名是19/351</li><li>比赛：参加了各种水比赛（比如天梯赛，ccf ccsp，数学建模等），得的奖也都是各种水奖，不值一提。</li><li>项目：学校的小型创新项目（飞行棋），大创项目（人脸表情识别，运动物体检测），以及各种课设。</li><li>科研：关于生物信息大数据的SCI一篇，共同一作（名字排名是第二个）</li><li>其他：六级502。</li><li>夏令营：南大lamda（被拒），北大信工（被拒），北航计算机（优营）</li><li>预推免：清华软件（通过），北大软微（通过初审，没去）</li></ul><hr><p>大三下学期，学习有要求只能开三份成绩排名的证明，所以无法采取海投策略，于是只投了三个。</p><p>由于南大lamda是5.20截止，我在5.19突然决定投一个试试，所以很匆忙，材料写的乱七八糟，甚至连实验室的名称都写错了。人家的名字是lamda，是Learning And Mining from DatA的意思，我还以为是LAMBDA表达式的意思，结果个人陈述中的实验室名字打错了。。。。。果然收到了南大lamda拒信，被拒是必然的，且不说我连人家名字都打错了，我自身的水平也不够，所以并不是特别沮丧。不过这封拒信写的还挺好，让人即使被拒也挺开心的。。<img src="/img/hj.png" alt="滑稽"></p><p><div align="center">  <img src="/img/lamda.jpg"></div><br>之后准备北大信工的夏令营材料，两封副教授以上的推荐信，个人陈述，以及各种表格和复印件，之后还拜托了我的本科导师帮忙联系了北大信工的一位老师，得到了标准答复：夏令营见。结果最后没入营，凉凉。</p><p>北航计算机如果不报直博的话就不需要推荐信，各种材料也不麻烦，个人陈述的那一项我直接把简历发上去了，也没有提前联系老师（事后比较后悔，尽量能提前联系就提前联系吧）。成功入营，一共入了598人，惊了。</p><hr><h1 id="北航夏令营之行"><a href="#北航夏令营之行" class="headerlink" title="北航夏令营之行"></a>北航夏令营之行</h1><h3 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h3><p>上午报道交材料交csp成绩来抵机试（本人315分，当次排名2.28%，历史排名3.9%），之后各个实验室的老师上台宣讲，下午机试不用参加所以回宾馆看片+复习。晚上面试名单出来了，只剩下284人，太惨烈了。面试分两天，我是第一天，是我们组第二个面试的，当天晚上非常紧张，一直复习到凌晨三点才睡觉。</p><h3 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h3><p>八点到面试门口，第一个进去了，里面传来了阵阵笑声，不知问了啥会引发大笑。不过我在外面可是紧张的不得了，拿着笔记来回走。要是之前好好复习的话就不会有那么多事了。八点半左右，轮到我了，进去发了简历。先抽一道政治题，如何建设网络强国，这题我在保研经验上看到过，没想到我自己也抽到了，瞎几把答，要加强网络教育巴拉巴拉，前言不搭后语，不过老师好像也不怎么在意这部分。之后英语测试，先读一段文章，再翻译，是软件工程方面的。我读的简直是灾难，加上紧张，读完一遍完全不知道读的是什么，声音都有点颤抖，之后翻译也胡编乱造，有个词实在是编不出来了就过了。之后开始了数学与专业面试。</p><ul><li><p><font size="4">什么是良序（离散数学）</font><br>&emsp;&emsp;我本科学的离散数学里没提到过良序的概念，后来我才知道。不过老师又问了什么是偏序，才勉强答上。</p><blockquote><p>设集合(S,≤)为一全序集，≤是其偏序关系，若对任意的S的非空子集，在其序下都有最小元素，则称≤为良序关系，(S,≤)为良序集。</p></blockquote></li><li><p><font size="4">A是矩阵，Ax=b什么时候有解（线性代数）</font><br>&emsp;&emsp;其实只要从矩阵A的秩与增广矩阵[A b]的秩的关系上回答就好，我说得好复杂，还解释了一通线性空间的生成。老师追问什么是线性空间，我记得要满足一系列要求的域就是线性空间，然而当时太紧张了，这一系列要求全忘了。。。。</p><blockquote><p>设V是一个非空集合，P是一个域。若：<br>1.在V中定义了一种运算，称为加法，即对V中任意两个元素α与β都按某一法则对应于V内惟一确定的一个元素α+β，称为α与β的和。<br>2.在P与V的元素间定义了一种运算，称为纯量乘法(亦称数量乘法)，即对V中任意元素α和P中任意元素k，都按某一法则对应V内惟一确定的一个元素kα，称为k与α的积。<br>3.加法与纯量乘法满足以下条件：<br>1) α+β=β+α，对任意α，β∈V.<br>2) α+(β+γ)=(α+β)+γ，对任意α，β，γ∈V.<br>3) 存在一个元素0∈V，对一切α∈V有α+0=α，元素0称为V的零元.<br>4) 对任一α∈V，都存在β∈V使α+β=0，β称为α的负元素，记为-α.<br>5) 对P中单位元1，有1α=α(α∈V).<br>6) 对任意k，l∈P，α∈V有(kl)α=k(lα).<br>7) 对任意k，l∈P，α∈V有(k+l)α=kα+lα.<br>8) 对任意k∈P，α，β∈V有k(α+β)=kα+kβ，<br>则称V为域P上的一个线性空间，或向量空间。</p></blockquote></li><li><p><font size="4">在我的论文中，我做了什么贡献。</font><br>&emsp;&emsp;如实回答（写代码，调参实验，服务器搭建等）</p></li><li><p><font size="4">简历提到的一个软件著作权的内容与具体原理（运动检测）</font><br>&emsp;&emsp;如实回答（背景减除法，然后解释了下具体细节）</p></li><li><p><font size="4">用什么数据结构存储一个稀疏矩阵，用这个结构怎样计算矩阵乘法（三元组+十字链表）</font><br>&emsp;&emsp;没想起来十字链表，答得一塌糊涂。</p></li><li><p><font size="4">遇到一个新的自己从未接触过的领域时如何学习。</font><br>&emsp;&emsp;阅读相关论文，看慕课，看博客，看别人实现好的例子，然后自己慢慢设计。问到这种问题时最好配合自己的亲身经历说明。</p></li><li><p><font size="4">当做项目的时候是先根据前人经验做出一个雏形，还是从头自己细细琢磨</font><br>&emsp;&emsp;答：看ddl，近的话就先做出来，交完之后再研究具体原理，远的话就慢慢研究。同样配合自己的亲身经历说明。</p></li></ul><p>结束了，感觉面试很糟糕，问的所有知识点我全没答上来，自己复习的知识点又全没考，高数机器学习一点都没问，感觉会挂了，我都做好啥都没有的准备可，开始玩，当天下午去了颐和园，晚上去了鸟巢水立方，第二天去了长城玩。没有联系老师，也没继续复习薄弱的知识点，因为真的觉得自己应该凉了。。</p><p>7.13晚，官网放出了优秀营员名单，我居然过了woc，一共过了173人，我的分数还贼高281.951/300，排名第九，回头分析一下原因，应该是机试用CCF抵了一个比较高的分数，面试时论文加了分，简历上内容比较多，再加上老师问的我的一些经历，我回答的也比较具体。</p><p><div align="center">  <img src="/img/cj.png"></div><br>得知优营后瞬间高兴地不得了，但明天要找目标导师签字，我却没有联系老师，又瞬间慌得不行。找了一晚上，发了邮件，直到第二天早上也没回。。。。</p><h3 id="7-14"><a href="#7-14" class="headerlink" title="7.14"></a>7.14</h3><p>早上领取表格，昨天联系的老师没回我，办公室也没人，一堆人都在走廊闲逛。等了半天不知如何是好，然后就去找了同实验室的hd老师，到了的时候发现里面正在面试。</p><p>等了一会没人后我才进去，原来其他人早就联系好了，并且九点多一起开了个会，我十点多才过来，这已经属于霸面了。老师看了我的简历，问我机试咋样，我说csp抵了，2.28%，老师笑着说还凑活。又问我有什么优势，我赶紧往我准备好的地方引导，我说我动手能力强，用到的一些算法能理解其原理，比如论文用到了SVM。果然老师又笑了，对这个很感兴趣，我开始狂推SVM，老师中途打断我问了问核函数，问了SVM的优化方式（SMO）。SVM还没推完就不用说了，老师说行了，然后给我介绍了下实验室情况，我有什么问题也可以问，这个实验室是一群老师带学生，每个老师并不独立，就是说不用纠结一定要选某个老师，于是我选择了接受实验室内老师的调剂。</p><p>但要进这个实验室还要经过一轮实验室的面试，过去一看有好多人排队，我没提前联系所以只能最后进去了。中午出去吃了个饭，又回去等着，两点多终于只剩我一个人了，才进去开始面试。然而这个面试不是问学习的，而且唠嗑。老师们都很年轻，整个过程特别欢乐。问了我为什么选择北航，问我有什么爱好，我说我喜欢看动漫，老师让我举三个最喜欢的，我说钢之炼金术师，命运石之门，进击的巨人，有一个老师居然问我钢炼喜欢03还是09版，我说09，老师说那太遗憾了，我说03我也看了。然后还问我逛b站吗，是大会员吗。问了我受到的最大挫折是啥等等。全程特别欢乐，感觉很快就十多分钟就出来了，上午进去的同学有20多分钟。</p><p>出来感觉稳了，跟各个小伙伴分享刚才的面试，简直太欢乐了，跟面试老师聊动漫你敢信。<img src="/img/hj.png" alt="滑稽"> 把表交了就回去了。下午五点，收到了offer，被录取了，接收我的老师就是跟我聊动漫的gyf老师，留在北航培养（有杭州和国安），专硕或学硕还没定，要之后再定。北航之行终于告一段落，北航保底，九推也会信心倍增吧。</p><p>7.15，早上去北航校医院体检，结束后就离开北京了。 之后的暑假，前所未有的放松，8月中旬回到学校，开始新一轮的复习，准备预推免。</p><hr><h1 id="清华软件预推免"><a href="#清华软件预推免" class="headerlink" title="清华软件预推免"></a>清华软件预推免</h1><p>我报名的是专硕，通过初审的有90人左右。</p><h3 id="9-15"><a href="#9-15" class="headerlink" title="9.15"></a>9.15</h3><p>复试第一天，早上去东主楼交材料。由于当时我们的排名还没出，所以我交了一张“无法开具排名证明的证明”。。。。我佛了，老师让我等结束后回学校等排名出来，重新盖一份申请表邮寄过来。之后回去歇了一会下午一点机试。</p><p>机房环境很舒服，键盘鼠标也挺舒服，就是电脑有点卡。三小时三道题，发题纸然后把代码存到固定位置。先看第一页的说明，评测居然用的是vs的release模式，1秒内运行完毕即可，这样应该不会超时，还挺良心，然后开始做题。第一题看完我笑了，质因数分解，快速敲完。第二题看完我又笑了，给出二叉树前序中序遍历结果，求从根节点到所有叶节点的路径中遇到的节点之和等于某个特定的数的路径个数，快速敲完。</p><p>剩下的时间全攻第三题。压缩字符串，读了半天题，本想用动态规划，但是本人没打过acm，oj练得也比较少，咋想都想不出大问题跟子问题有什么关系，于是写了个超级暴力的超大dfs，把所有可能的压缩情况全例举出来一个一个比较，没想到样例居然过了，小规模数据可以过，这样能骗点分了。之后的时间就一直在想办法优化，比如用集合记忆优化，循环外提，提前判断，把sstream改成sprintf，确实优化了一些，但复杂点的样例还是很浪费时间，在release模式下勉强一秒，估计根本得不了几分了。</p><p>唉，如果打过acm的话，机试是有绝对优势的，我还是太菜了。<img src="/img/cry.jpg" alt="哭"></p><h3 id="9-16"><a href="#9-16" class="headerlink" title="9.16"></a>9.16</h3><p>在东主楼面试，看了下名单，我还是在第二位面试，跟北航一样，偷偷瞄了下面试的教室，我靠还有摄像机，我看着摄像机很紧张啊，我甚至连第一个人什么时候进去的都不知道，其他人问了别人我才知道原来已经开始了。</p><p>轮到我了，进去本打算用手机录音，结果手抖没按上，日。给老师发了简历，然后自我介绍一下。于是各个老师轮着问，问了很多： </p><blockquote><ul><li>论文内容，我的工作，</li><li>做运动物体检测系统的原因，难点，我的工作，</li><li>问关于大创的内容，</li><li>问关于飞行棋软件著作权中的伪完全化博弈信息是什么意思（不要乱起高端的名字）</li></ul></blockquote><p>到此我还答得不错，之后突然来了个英文问题，把我问蒙了，大意应该是让我详细解释一下神经网络，我艹我没准备这个，我尝试了半天没说出来，最后放弃了，老师问我六级考口语了吗我说没有，太尴尬了。</p><p>然后问我为啥C++73分，我说的73分的是C#，选修课，平时分40分，而我缺席了几次，我的C++91分。之后老师问了数据库，什么是控制设计和逻辑设计，什么是表空间，数据库应该怎样设计，我只简单说了说数据库设计过程，其他两个概念不会。（为什么我完全没听过这些概念啊，看来我们学的数据库是阉割版的。。）老师说你数据库90分学的挺好啊，怎么答不上来呢。估计老师也感到尴尬，说我们还是回到项目上来吧。接下来又问了一些问题： </p><blockquote><ul><li>什么是大创，这个优秀结题的含金量如何，</li><li>简单问了下我简历上提到的视频制作，</li><li>我想做什么方向，</li><li>除了动手能力还有什么优势，</li><li>最后问了我觉得机试怎么样，</li></ul></blockquote><p>这些回答的也挺好，最后的问题很关键，我们所有人都是不知道机试成绩的，老师手里有成绩，但不会告诉你。如果对自己答题的情况很了解就会加分。我如实说我感觉前两题很简单（此时一个老师突然抬头看我），第三题写了个很暴力的算法应该会超时，老师问我为什么没能想出更好的解决办法，问我学没学过算法，我说学过，但没接受过acm培训，都是自己练习的。就结束了，全程感觉很糟糕，英语没回答上来，专业课（数据库）也没回答上来，感觉没啥希望。</p><p>清华之旅就这样结束了总的来说，我这次是比较失败的，没能展示出最好的自己，要是能复习一下数据库的话，要是能做准备准备英语的话。。。唉北航当初也是这样，幸好过了，没过的话我现在就真的无学可上了。</p><p>回学校后，准备把清华没填好的表重新盖章邮寄，跑来跑去一个表盖了五个章。。下午刚刚顺丰邮寄完毕，就收到一封邮件，是清软offer，居然过了。。。卧槽我过了，各种激动，还跟教务处老师确定了一下后续流程，才终于放下心来。 </p><p>后来我又收到了北大软微的初审通过邮件，不过我已经决定去清华了，就回了一封邮件放弃参加。9月28日凌晨填报系统，9月29日下午四点左右，整个流程走完，保研结束了。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要问保研最重要的是什么，那必须成绩排名是No.1。各个学校的前几名几乎都是横扫各大学校的夏令营，当时各个学校入营名单出来时候，我们都在说“怎么又是这些人啊”。比较流行的一个说法就是，论文与竞赛只能锦上添花，不能雪中送炭，所以学习成绩是最重要的，当然在保证成绩的情况下，其他经历当然是越多越好。当然如果你各种大奖拿到手软，SCI随便发，这种巨佬除外。</p><p>机试也很重要，练习机试可以用leetcode，洛谷，pta等，Poj我感觉太难了（菜鸡如我）。大模拟类的题可以看ccf csp认证历次的第三题。</p><p>然后在准备材料的时候有几种要认真准备：</p><ol><li>简历内容一定要好好斟酌，要尽可能把低端的东西写得高大上一点，并且要完全理解你做的东西是什么，做它的目的是什么，用到了什么知识/语言/框架/算法等，各种细节全都要非常了解，并且还要了解你用到的东西的相关扩展知识。</li><li>推荐信，我一般是把推荐信自己写好，然后发给老师看一下，有的老师会提出一些修改意见，之后老师同意就可以签字了。在写的时候一定要结合实际经历，而不能全篇都是概括性的评价，比如“该同学学习优秀，勤奋上进”之类的，主要应该写“在我的指导下，该同学完成了……，取得了……的成绩”等，内容越详细越好。</li><li>个人陈述，我是按照从大一到大三的时间顺序写的，在什么时候做了什么，由此引发的我某某知识的兴趣，于是怎样学习等等。除学习之外的内容也可以写进去，比如参加了学校的某活动，比如学生会工作等。最后再展望一下研究生的生活，注意内容最好要提到目标院校，否则对方老师可能会认为你只写了一份然后海投，没有诚意。（虽然我感觉老师根本不看这些材料）</li></ol><p>以上就是我的没什么卵用的保研经验，希望能帮助看到的同学。</p><p>保研终于结束了，最难的一道坎算是完全跨过去了。记得清软初审结果还没出的时候，我就心慌的到处看有没有最新消息，那时能够通过初审真的很幸运，因为我的排名实在是太低了，应该是排在我前面的人没有报清软的，才让我捡了个漏。。。如今，我已经把我手里的一副烂牌打出了最好的效果，这一切真的跟做梦一样。收到邮件offer之后，我还盯着邮件掐自己的脸，幸好我没有醒过来。我的运气真的很好，不过我不能总寄希望于运气，还是得提升自己的水平才行。我对研究生生活有几分期待，也有几分恐惧，希望我能将恐惧的心情不断减少吧，当自己成为真正的大佬之时（很遥远），自然就会信心倍增了。之后还有更大的挑战等着我，加油吧。</p><hr><p><font size="4">最后，计算机保研的同学可以加这个群：<strong>605176069</strong></font><br>群友人均保研清北，遇到什么问题可以在里面问问学长学姐。<br><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><img src="/img/hj.png" alt="滑稽"><br>希望每个人的努力都能有所回报！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="保研" scheme="http://yoursite.com/tags/%E4%BF%9D%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习】手撸一个BP神经网络（支持minibatch，Adam优化）</title>
    <link href="http://yoursite.com/post/5e34cb8d.html"/>
    <id>http://yoursite.com/post/5e34cb8d.html</id>
    <published>2019-04-15T11:39:27.000Z</published>
    <updated>2019-04-15T12:10:17.997Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/1.jpg" alt="封面"></p><p>每个函数以及变量的含义已经写在注释中。<br>使用数据：<a href="/download/spambase.csv">点击下载</a><br>测试结果：（第一列为训练集acc，第二列为测试集acc，每行的行数为神经网络层数，每层20个神经元）<br><img src="/img/BP.jpg" alt="结果"></p><p>测试的时候层数不能太深，容易梯度爆炸<br>所需头文件：</p><pre><code>#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;fstream&gt;#include&lt;sstream&gt;</code></pre><p>BP类定义：</p><pre><code>class BP{private:    vector&lt;vector&lt;vector&lt;double&gt;&gt;&gt; w;//需要学习的权重    vector&lt;vector&lt;double&gt;&gt;b;//每层神经网络的偏置    int layers;//层数    vector&lt;int&gt;nl;//每层神经元数量    int m;//样本总数    int act;//激活函数种类    double c;//正则化系数    double a;//学习率    int seed;//随机种子    bool adam;//是否使用adam优化    double testp;//训练集所占比重    vector&lt;vector&lt;double&gt;&gt;za;//记录每个神经元激活值    vector&lt;vector&lt;double&gt;&gt;zz;//记录每个神经元输入值    vector&lt;vector&lt;double&gt;&gt;dz;//记录每个神经元输入的偏导    double forward(double **x, int *y, int q); //第q个样本前向传播    void back(double **x, int *y, int q); //第q个样本反向传播    double relu(double x) { return max(0.0, x); } //以下为三种激活函数以及其导函数    double drelu(double x) { return x &gt;= 0 ? 1 : 0; }    double sigmod(double x) { return 1 / (1 + exp(-x)); }    double dsigmod(double x) { return sigmod(x)*(1 - sigmod(x)); }    double tanh(double x) { return std::tanh(x); }    double dtanh(double x) { return 1 - std::tanh(x)*std::tanh(x); }public:    BP(int layers, int m, int *nl, double a, double c, string act = &quot;relu&quot;, double testp = 0.7, bool adam = false, int seed = 0);    void init();    void train(double **x, int *y, int minibatch); //开始训练    double testacc(double**x, int *y); //计算测试集acc    double trainacc(double**x, int *y);//计算训练集acc    void norminput(double**x); //正则化输入};</code></pre><p>下面给出每个函数的定义：<br>构造函数，传进来层数不包括最后的输出层，所以在构造函数里加上，假设是二分类，所以最后一层只需要一个神经元。</p><pre><code>BP::BP(int layers, int m, int *nl, double a, double c, string act, double testp, bool adam, int seed){    this-&gt;layers = layers + 1;    this-&gt;m = m;    for (int i = 0; i &lt; layers; i++)        this-&gt;nl.emplace_back(nl[i]);    this-&gt;nl.emplace_back(1);    if (act == &quot;relu&quot;)        this-&gt;act = 1;    else if (act == &quot;tanh&quot;)        this-&gt;act = 2;    else if (act == &quot;sigmod&quot;)        this-&gt;act = 3;    this-&gt;seed = seed;    this-&gt;a = a;    this-&gt;c = c;    this-&gt;adam = adam;    this-&gt;testp = testp;}</code></pre><p>初始化函数，各种申请空间和随机初始化，不解释</p><pre><code>void BP::init(){    srand(seed);    w = vector&lt; vector&lt;vector&lt;double&gt;&gt;&gt;(layers - 1);    for (int i = 0; i &lt; layers - 1; i++)    {        w[i] = vector&lt;vector&lt;double&gt;&gt;(nl[i + 1]);        for (int j = 0; j &lt; nl[i + 1]; j++)        {            w[i][j] = vector&lt;double&gt;(nl[i]);            for (int k = 0; k &lt; nl[i]; k++)                w[i][j][k] = rand() % 1000 / (double)100000 - 0.005;        }    }    b = vector&lt;vector&lt;double&gt;&gt;(layers - 1);    for (int i = 0; i &lt; layers - 1; i++)    {        b[i] = vector&lt;double&gt;(nl[i + 1]);        for (int j = 0; j &lt; nl[i + 1]; j++)            b[i][j] = rand() % 1000 / (double)100000 - 0.005;    }    za = vector&lt;vector&lt;double&gt;&gt;(layers);    for (int i = 0; i &lt; layers; i++)        za[i] = vector&lt;double&gt;(nl[i]);    zz = vector&lt;vector&lt;double&gt;&gt;(layers);    for (int i = 0; i &lt; layers; i++)        zz[i] = vector&lt;double&gt;(nl[i]);    dz = vector&lt;vector&lt;double&gt;&gt;(layers);    for (int i = 0; i &lt; layers; i++)        dz[i] = vector&lt;double&gt;(nl[i]);}</code></pre><p>单个样本前向传播，第一层就是x的输入，然后每层每个神经元依次计算输入与激活值，返回该样本的log损失误差，最后一层用sigmod计活函数</p><pre><code>double BP::forward(double **x, int *y, int q){    for (int i = 0; i &lt; nl[0]; i++)        za[0][i] = x[q][i];    for (int i = 0; i &lt; layers - 1; i++)    {        for (int j = 0; j &lt; nl[i + 1]; j++)        {            double z = 0;            for (int k = 0; k &lt; nl[i]; k++)                z += w[i][j][k] * za[i][k];            z += b[i][j];            zz[i + 1][j] = z;            if (i == layers - 2)                z = sigmod(z);            else            {                switch (act)                {                case 1:z = relu(z); break;                case 2:z = tanh(z); break;                case 3:z = sigmod(z); break;                }            }            za[i + 1][j] = z;        }    }    double J = y[q] * log(za[layers - 1][0] + 1e-8) + (1 - y[q])*log(1 - za[layers - 1][0] + 1e-8);    return J;}</code></pre><p>单个样本反向传播求导，最后一层的导数并不是定义为<code>a-y</code>，而是通过损失函数对a的导与sigmod函数对z的导相乘化简而来的</p><pre><code>void BP::back(double**x, int *y, int q){    dz[layers - 1][0] = za[layers - 1][0] - y[q];    for (int i = layers - 2; i &gt; 0; i--)    {        for (int j = 0; j &lt; nl[i]; j++)        {            double dd = 0;            for (int k = 0; k &lt; nl[i + 1]; k++)                dd += w[i][k][j] * dz[i + 1][k];            switch (act)            {            case 1:dd *= drelu(zz[i][j]); break;            case 2:dd *= dtanh(zz[i][j]); break;            case 3:dd *= sigmod(zz[i][j]); break;            }            dz[i][j] = dd;        }    }}</code></pre><p>训练函数，如果minibatch大于m，就直接等于m，dnum为一轮的次数，每求完一轮，计算损失函数，与上一轮相比，相差不大于1e-6，就结束训练,如果训练200轮还没收敛，也结束训练<br>其中dw为损失函数对每层的w的偏导，db同理，vdw与vdb为dw与db的指数加权平均数，sdw与sdb为(dw)²与(db)²的指数加权平均数，这四个变量用来做adam优化的梯度下降</p><pre><code>void BP::train(double **x, int *y, int minibatch){    vector&lt;vector&lt;vector&lt;double&gt;&gt;&gt; dw(layers - 1);    for (int i = 0; i &lt; layers - 1; i++)    {        dw[i] = vector&lt;vector&lt;double&gt;&gt;(nl[i + 1]);        for (int j = 0; j &lt; nl[i + 1]; j++)            dw[i][j] = vector&lt;double&gt;(nl[i]);    }    vector&lt;vector&lt;double&gt;&gt;db(layers - 1);    for (int i = 0; i &lt; layers - 1; i++)        db[i] = vector&lt;double&gt;(nl[i + 1]);    vector &lt;vector&lt;vector&lt;double&gt;&gt;&gt;vdw(layers - 1);    for (int i = 0; i &lt; layers - 1; i++)    {        vdw[i] = vector&lt;vector&lt;double&gt;&gt;(nl[i + 1]);        for (int j = 0; j &lt; nl[i + 1]; j++)            vdw[i][j] = vector&lt;double&gt;(nl[i], 0);    }    vector&lt;vector&lt;double&gt;&gt;vdb(layers - 1);    for (int i = 0; i &lt; layers - 1; i++)        vdb[i] = vector&lt;double&gt;(nl[i + 1], 0);    vector &lt;vector&lt;vector&lt;double&gt;&gt;&gt;sdw(layers - 1);    for (int i = 0; i &lt; layers - 1; i++)    {        sdw[i] = vector&lt;vector&lt;double&gt;&gt;(nl[i + 1]);        for (int j = 0; j &lt; nl[i + 1]; j++)            sdw[i][j] = vector&lt;double&gt;(nl[i], 0);    }    vector&lt;vector&lt;double&gt;&gt;sdb(layers - 1);    for (int i = 0; i &lt; layers - 1; i++)        sdb[i] = vector&lt;double&gt;(nl[i + 1], 0);    double Jlast = 0;    double Jnow = 100000;    int t = 1;    int dnum = (int)(m*testp) % minibatch == 0 ? (m*testp) / minibatch : (m*testp) / minibatch + 1;    int anum = 0;    while (abs(Jlast - Jnow) &gt; 1e-5)    {        Jlast = Jnow;        Jnow = 0;        int m1 = 0, m2 = min((int)(m*testp), m1 + minibatch);        for (int ci = 0; ci &lt; dnum; ci++)        {            for (int i = 0; i &lt; layers - 1; i++)                for (int j = 0; j &lt; nl[i + 1]; j++)                    for (int k = 0; k &lt; nl[i]; k++)                        dw[i][j][k] = 0;            for (int i = 1; i &lt; layers; i++)                for (int j = 0; j &lt; nl[i]; j++)                    db[i - 1][j] = 0;            //cout &lt;&lt; &quot;epoch &quot; &lt;&lt; t/dnum +1 &lt;&lt; &quot;: &quot; &lt;&lt; ci + 1 &lt;&lt; &quot;/&quot; &lt;&lt; dnum &lt;&lt; endl;            if (ci != 0)                m1 += minibatch, m2 = min((int)(m*testp), m2 + minibatch);            double J = 0;            for (int i = m1; i &lt; m2; i++)            {                double j = forward(x, y, i);                //cout &lt;&lt; j &lt;&lt; endl;                J += j;                back(x, y, i);                for (int i = 0; i &lt; layers - 1; i++)                    for (int j = 0; j &lt; nl[i + 1]; j++)                        for (int k = 0; k &lt; nl[i]; k++)                            dw[i][j][k] += dz[i + 1][j] * za[i][k];                for (int i = 1; i &lt; layers; i++)                    for (int j = 0; j &lt; nl[i]; j++)                        db[i - 1][j] += dz[i][j];            }            J /= -(double)(m2 - m1);            Jnow += J;            for (int i = 0; i &lt; layers - 1; i++)                for (int j = 0; j &lt; nl[i + 1]; j++)                    for (int k = 0; k &lt; nl[i]; k++)                    {                        dw[i][j][k] = dw[i][j][k] / (double)(m2 - m1) + w[i][j][k] * c / (m2 - m1);                        if (!adam)                            w[i][j][k] -= a * dw[i][j][k];                        else                        {                            vdw[i][j][k] = 0.9*vdw[i][j][k] + 0.1*dw[i][j][k];                            sdw[i][j][k] = 0.999*sdw[i][j][k] + 0.001*dw[i][j][k] * dw[i][j][k];                            double vdwt = vdw[i][j][k] / (1 - pow(0.9, t));                            double sdwt = sdw[i][j][k] / (1 - pow(0.999, t));                            w[i][j][k] -= a * vdwt / sqrt(sdwt + 1e-8);                        }                    }            for (int i = 1; i &lt; layers; i++)                for (int j = 0; j &lt; nl[i]; j++)                {                    db[i - 1][j] = db[i - 1][j] / (double)(m2 - m1);                    if (!adam)                        b[i - 1][j] -= a * db[i - 1][j];                    else                    {                        vdb[i - 1][j] = 0.9*vdb[i - 1][j] + 0.1*db[i - 1][j];                        sdb[i - 1][j] = 0.999*sdb[i - 1][j] + 0.001*db[i - 1][j] * db[i - 1][j];                        double vdbt = vdb[i - 1][j] / (1 - pow(0.9, t));                        double sdbt = sdb[i - 1][j] / (1 - pow(0.999, t));                        b[i - 1][j] -= a * vdbt / (sqrt(sdbt + 1e-8));                        //cout &lt;&lt; db[i - 1][j] &lt;&lt; &quot; &quot; &lt;&lt; vdbt / (sqrt(sdbt + 1e-8)) &lt;&lt; endl;                    }                }            t++;        }        //cout &lt;&lt; Jnow &lt;&lt; endl;        double JC = 0;        for (int i = 0; i &lt; layers - 1; i++)            for (int j = 0; j &lt; nl[i + 1]; j++)                for (int k = 0; k &lt; nl[i]; k++)                    JC += w[i][j][k] * w[i][j][k];        JC *= c;        JC /= 2 * (m*testp);        Jnow += JC;        //printf(&quot;%lf %lf\n&quot;, Jnow, Jlast);        if (t / dnum &gt;= 200)            break;    }}</code></pre><p>两个测试函数，没啥好说的</p><pre><code>double BP::testacc(double**x, int *y){    int m1 = (int)(m*testp);    int tr = 0;    for (int i = m1; i &lt; m; i++)    {        forward(x, y, i);        if (za[layers - 1][0] &gt;= 0.5&amp;&amp;y[i] == 1)            tr++;        if (za[layers - 1][0] &lt; 0.5&amp;&amp;y[i] == 0)            tr++;    }    return tr / (double)(m - m1);}double BP::trainacc(double**x, int *y){    int tr = 0;    for (int i = 0; i &lt; (int)(m*testp); i++)    {        forward(x, y, i);        if (za[layers - 1][0] &gt;= 0.5&amp;&amp;y[i] == 1)            tr++;        if (za[layers - 1][0] &lt; 0.5&amp;&amp;y[i] == 0)            tr++;    }    return tr / (double)(m*testp);}</code></pre><p>正则化输入，每个x减去均值并除以范围（标准差也可以）</p><pre><code>void BP::norminput(double**x){    for (int i = 0; i &lt; nl[0]; i++)    {        double avg = 0;        double maxx = 0;        double minn = 99999999;        for (int j = 0; j &lt; m; j++)        {            avg += x[j][i];            maxx = max(maxx, x[j][i]);            minn = min(minn, x[j][i]);        }        avg /= m;        for (int j = 0; j &lt; m; j++)            x[j][i] = (x[j][i] - avg) / (maxx - minn);    }}</code></pre><p>最后是主函数，读入文件，尝试测试不同层数的神经网络</p><pre><code>int main() {    ifstream f;    f.open(&quot;spambase.csv&quot;);    if (!f.is_open())    {        cout &lt;&lt; &quot;open error&quot; &lt;&lt; endl;        return 0;    }    string line;    int m = 0;    int n = 0;    double **x = new double*[10000];    int *y = new int[10000];    while (getline(f, line))    {        int n1 = 0;        x[m] = new double[1000];        istringstream sin(line);        string temp;        while (getline(sin, temp, &#39;,&#39;))        {            x[m][n1] = atof(temp.c_str());            //cout &lt;&lt; x[m][n1] &lt;&lt; endl;            n1++;        }        y[m] = x[m][n1 - 1] == -1 ? 0 : 1;        m++;        n = n1 - 1;    }    f.close();    int *nl = new int[11];    nl[0] = n;    nl[1] = 20;    nl[2] = 20;    nl[3] = 20;    nl[4] = 20;    nl[5] = 20;    nl[6] = 20;    for (int i = 1; i &lt;= 6; i++)    {        BP B(i, m, nl, 0.01, 0.0001, &quot;tanh&quot;, 0.7, true, 0);        B.init();        B.norminput(x);        B.train(x, y, 64);        double trainacc = B.trainacc(x, y);        double acc = B.testacc(x, y);        printf(&quot;%lf %lf\n&quot;, trainacc, acc);        //system(&quot;pause&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="手撸" scheme="http://yoursite.com/tags/%E6%89%8B%E6%92%B8/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习】手撸一个逻辑回归</title>
    <link href="http://yoursite.com/post/723f47a8.html"/>
    <id>http://yoursite.com/post/723f47a8.html</id>
    <published>2019-04-05T05:52:45.000Z</published>
    <updated>2019-04-05T06:05:19.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>flag为false时为测试集，为true时为训练集</p><p>J函数：logistics代价函数，为对数代价。</p><p>logistics函数：x特征，y标签，m1样本起始点，m2样本结束点，n特征数，a学习率，c正则化参数，返回n+1长度的数组，为训练好的参数。</p><p>kfold函数：x特征，y标签，n特征数，m样本数，k折数，返回k折平均acc。</p><p>测试数据： <a href="/download/breast-w.csv">点击下载</a><br>数据说明：第10列为标签，-1与1，前九列为特征。</p><p>代码运行结果：（5折交叉验证）<br><img src="/img/5.png" alt="结果"><br>代码：</p><pre><code>#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;cmath&gt;#include&lt;set&gt;#include&lt;string.h&gt;#include&lt;fstream&gt;#include&lt;sstream&gt;#include&lt;ctime&gt;using namespace std;bool flag[10000];double J(double *s, double **x, int *y,int m1, int m2, int n,double c){    double res = 0;    int fa = 0;    for (int i = m1; i &lt; m2; i++)    {        if (!flag[i])        {            fa++;            continue;        }        double z = -s[0];        for (int j = 1; j &lt;= n; j++)            z -= s[j] * x[i][j-1];        //cout &lt;&lt; z &lt;&lt; endl;        double h = (double)1 / (1 + exp(z));        //cout &lt;&lt; h &lt;&lt; endl;        double cost = 0;        if (y[i] == 1)            cost = -log(h);        else            cost = -log(1 - h);        //cout &lt;&lt; cost &lt;&lt; endl;        res += cost;    }    res /= m2-m1-fa;    double res2 = 0;    for (int i = 1; i &lt;= n; i++)        res2 += s[i] * s[i];    res2 *= c;    res2 /= 2 * (m2 - m1 - fa);    return res + res2;}double* logistic(double **x, int *y, int n,int m1, int m2,double a,double c){    double *s = new double[n + 1];//θ    srand(time(0));    for (int i = 0; i &lt; n + 1; i++)        s[i] = rand()%100/(double)100;//随机初始化    cout &lt;&lt; s[0] &lt;&lt; endl;    double last = 0;    double now = J(s, x, y, m1,m2, n, c);    double *temp = new double[n + 1];    while (abs(last - now) &gt; 0.00001)    {        //cout &lt;&lt;  now &lt;&lt; endl;        for (int i = 0; i &lt;= n; i++)        {            double mqiuhe = 0;            int fa = 0;            for (int k = m1; k &lt; m2; k++)            {                if (!flag[k])                {                    fa++;                    continue;                }                double z = -s[0];                for (int j = 1; j &lt;= n; j++)                    z -= s[j] * x[k][j-1];                double h = (double)1 / (1 + exp(z));                h -= y[k];                if(i!=0)                    h *= x[k][i-1];                mqiuhe += h;            }            mqiuhe /= m2-m1-fa;            mqiuhe *= a;            double C = 0;            if(i!=0)                C = c / (m2 - m1 - fa)*s[i],C *= a;            temp[i] = s[i] - mqiuhe - C;        }        for (int i = 0; i &lt;= n; i++)            s[i] = temp[i];        last = now;        now = J(s, x, y, m1,m2, n, c);    }    return s;}double kfold(double **x, int *y, int n, int m, int k){    double avg = 0;    double d = m / k;    for (int j = 0; j &lt; k; j++)    {        for (int i = 0; i &lt; m; i++)            flag[i] = true;        for (int i = d * j; i &lt; d*j + d; i++)//测试集            flag[i] = false;        double *s = logistic(x, y, n, 0, m, 0.1, 0.01);//学习率0.1，正则化权重0.01        int tr = 0;        for (int i = d * j; i &lt; d*j + d; i++)        {            double res = s[0];            for (int j = 1; j &lt;= n; j++)                res += s[j] * x[i][j - 1];            double h = (double)1 / (1 + exp(-res));            if (h &gt;= 0.5&amp;&amp;y[i] == 1)                tr++;            else if (h &lt; 0.5&amp;&amp;y[i] == 0)                tr++;            //cout &lt;&lt; h &lt;&lt; endl;        }        //cout &lt;&lt; tr &lt;&lt; endl;        double acc = tr / (double)d;        avg += acc;        cout &lt;&lt; &quot;第&quot; &lt;&lt; j +1 &lt;&lt; &quot;次acc值为：&quot; &lt;&lt; acc &lt;&lt; endl;    }    return avg / k;}int main() {    ifstream f;    f.open(&quot;breast-w.csv&quot;);    if (!f.is_open())    {        cout &lt;&lt; &quot;open error&quot; &lt;&lt; endl;        return 0;    }    string line;    int m = 0;    int n = 0;    double **x = new double*[10000];    int *y = new int[10000];    while (getline(f,line))       {            int n1 = 0;        x[m] = new double[1000];        istringstream sin(line);         string temp;        while (getline(sin, temp, &#39;,&#39;))         {            x[m][n1] = atof(temp.c_str());            //cout &lt;&lt; x[m][n1] &lt;&lt; endl;            n1++;        }        y[m] = x[m][n1 - 1]==-1?0:1;        m++;        n = n1-1;    }    double acc = kfold(x, y, n, m, 5);    cout &lt;&lt; &quot;平均：&quot; &lt;&lt; acc &lt;&lt; endl;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="手撸" scheme="http://yoursite.com/tags/%E6%89%8B%E6%92%B8/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【天梯赛】第四届团体程序设计天梯赛L2题解</title>
    <link href="http://yoursite.com/post/c332d4b5.html"/>
    <id>http://yoursite.com/post/c332d4b5.html</id>
    <published>2019-04-01T08:11:45.000Z</published>
    <updated>2019-04-01T08:44:10.603Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/4.jpg" alt="封面"></p><h1 id="L2-1-特立独行的幸福-（25分"><a href="#L2-1-特立独行的幸福-（25分" class="headerlink" title="L2-1 特立独行的幸福 （25分)"></a>L2-1 特立独行的幸福 （25分)</h1><p>对一个十进制数的各位数字做一次平方和，称作一次迭代。如果一个十进制数能通过若干次迭代得到 1，就称该数为幸福数。1 是一个幸福数。此外，例如 19 经过 1 次迭代得到 82，2 次迭代后得到 68，3 次迭代后得到 100，最后得到 1。则 19 就是幸福数。显然，在一个幸福数迭代到 1 的过程中经过的数字都是幸福数，它们的幸福是依附于初始数字的。例如 82、68、100 的幸福是依附于 19 的。而一个特立独行的幸福数，是在一个有限的区间内不依附于任何其它数字的；其独立性就是依附于它的的幸福数的个数。如果这个数还是个素数，则其独立性加倍。例如 19 在区间[1, 100] 内就是一个特立独行的幸福数，其独立性为 2×4=8。</p><p>另一方面，如果一个大于1的数字经过数次迭代后进入了死循环，那这个数就不幸福。例如 29 迭代得到 85、89、145、42、20、4、16、37、58、89、…… 可见 89 到 58 形成了死循环，所以 29 就不幸福。</p><p>本题就要求你编写程序，列出给定区间内的所有特立独行的幸福数和它的独立性。</p><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入在第一行给出闭区间的两个端点：1&lt;A&lt;B≤10^4</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>按递增顺序列出给定闭区间 [A,B] 内的所有特立独行的幸福数和它的独立性。每对数字占一行，数字间以 1 个空格分隔。</p><p>如果区间内没有幸福数，则在一行中输出 SAD。</p><h2 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h2><pre><code>10 40</code></pre><h2 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h2><pre><code>19 823 628 331 432 3</code></pre><p>注意：样例中，10、13 也都是幸福数，但它们分别依附于其他数字（如 23、31 等等），所以不输出。其它数字虽然其实也依附于其它幸福数，但因为那些数字不在给定区间 [10, 40] 内，所以它们在给定区间内是特立独行的幸福数。</p><h2 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h2><pre><code>110 120</code></pre><h2 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h2><pre><code>SAD</code></pre><p>思路：从A开始遍历，到B结束，如果当前数是幸福数，加入结果集合total，并保存当前数和其独立性，此后每次遍历其他数的时候，如果过程中得到了结果集合里的数，说明之前的数依赖当前的数，则删掉之前的数。每次遍历的时候再用一个集合判断是否循环。遍历结束时，把之前曾经是幸福数的每个数都遍历一下，出现在结果集合里的则是最终答案。</p><pre><code>#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include&lt;stack&gt;#include&lt;cmath&gt;#include&lt;set&gt;#include&lt;string.h&gt;using namespace std;int su(int n){    int j = sqrt(n);    for (int i = 2; i &lt;= j; i++)        if (n%i == 0)            return 1;    return 2;}int ping(int n){    int res = 0;    for (int i = 0;; i++)    {        res += (n % 10)*(n % 10);        n /= 10;        if (n == 0)            break;    }    return res;}int main() {    int x, y;    cin &gt;&gt; x &gt;&gt; y;    int res[10001];    int w[10001];    int geshu = 0;    set&lt;int&gt; total;    bool yilai[10001];    memset(yilai, false, sizeof(yilai));    for (int i = x; i &lt;= y; i++)    {        if (yilai[i])            continue;        int temp = i;        set&lt;int&gt; bianhuan;        bool yes = false;        if (i == 1)            yes = true;        while (temp != 1)        {            bianhuan.insert(temp);            temp = ping(temp);            if (bianhuan.count(temp) == 1)                break;            if (temp == 1)            {                yes = true;                break;            }            yilai[temp] = true;            if (total.count(temp) == 1)                total.erase(temp);        }        if (yes)        {            res[geshu] = i;            w[geshu] = su(i)*bianhuan.size();            total.insert(i);            geshu++;        }    }    if (geshu == 0)        cout &lt;&lt; &quot;SAD&quot;;    else    {        for(int i=0;i&lt;geshu;i++)            if (total.count(res[i]) == 1)            {                cout &lt;&lt; res[i] &lt;&lt; &quot; &quot; &lt;&lt; w[i] &lt;&lt; endl;            }    }}</code></pre><hr><h1 id="L2-2-冰岛人"><a href="#L2-2-冰岛人" class="headerlink" title="L2-2 冰岛人"></a>L2-2 冰岛人</h1><p>本人到现在还不知道到底该怎么做，改来改去也只有20分，等以后想到了解决方法再来更新。</p><hr><h1 id="L2-3-深入虎穴-（25分"><a href="#L2-3-深入虎穴-（25分" class="headerlink" title="L2-3 深入虎穴 （25分)"></a>L2-3 深入虎穴 （25分)</h1><p>著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。</p><p>内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。</p><h2 id="输入格式：-1"><a href="#输入格式：-1" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入首先在一行中给出正整数 N（&lt;10^5），是门的数量。最后 N 行，第 i 行（1≤i≤N）按以下格式描述编号为 i 的那扇门背后能通向的门：<br><code>K D[1] D[2] ... D[K]</code><br>其中<code>K</code>是通道的数量，其后是每扇门的编号。</p><h2 id="输出格式：-1"><a href="#输出格式：-1" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><pre><code>133 2 3 42 5 61 71 81 902 11 101 13001 1200</code></pre><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><pre><code>12</code></pre><p>思路：比赛的时候这道题我用了三种方法写，bfs，迪杰斯特拉，dfs，但最后最高也只得了18分，最后才知道，并不是默认1号门为入口，要找出入度为0的门作为入口，坑啊。之后直接dfs就行了，挺简单的。</p><pre><code>#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;cmath&gt;#include&lt;set&gt;#include&lt;string.h&gt;using namespace std;vector&lt;int&gt; v[100001];int maxx = 0;int bian = 0;void dfs(int i, int ju){    if (ju &gt; maxx)        maxx = ju, bian = i;    for (int j = 0; j &lt; v[i].size(); j++)        dfs(v[i][j], ju + 1);}int du[100001];int main() {    memset(du, 0, sizeof(du));    int n;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)    {        int k, t;        cin &gt;&gt; k;        for (int j = 0; j &lt; k; j++)        {            cin &gt;&gt; t;            v[i].push_back(t);            du[t]++;        }    }    int start = 0;    for(int i=1;i&lt;=n;i++)        if (du[i] == 0)        {            start = i;            break;        }    dfs(start, 1);    cout &lt;&lt; bian;}</code></pre><hr><h1 id="L2-4-彩虹瓶-（25分"><a href="#L2-4-彩虹瓶-（25分" class="headerlink" title="L2-4 彩虹瓶 （25分)"></a>L2-4 彩虹瓶 （25分)</h1><p>彩虹瓶的制作过程（并不）是这样的：先把一大批空瓶铺放在装填场地上，然后按照一定的顺序将每种颜色的小球均匀撒到这批瓶子里。</p><p>假设彩虹瓶里要按顺序装 N 种颜色的小球（不妨将顺序就编号为 1 到 N）。现在工厂里有每种颜色的小球各一箱，工人需要一箱一箱地将小球从工厂里搬到装填场地。如果搬来的这箱小球正好是可以装填的颜色，就直接拆箱装填；如果不是，就把箱子先码放在一个临时货架上，码放的方法就是一箱一箱堆上去。当一种颜色装填完以后，先看看货架顶端的一箱是不是下一个要装填的颜色，如果是就取下来装填，否则去工厂里再搬一箱过来。</p><p>如果工厂里发货的顺序比较好，工人就可以顺利地完成装填。例如要按顺序装填 7 种颜色，工厂按照 7、6、1、3、2、5、4 这个顺序发货，则工人先拿到 7、6 两种不能装填的颜色，将其按照 7 在下、6 在上的顺序堆在货架上；拿到 1 时可以直接装填；拿到 3 时又得临时码放在 6 号颜色箱上；拿到 2 时可以直接装填；随后从货架顶取下 3 进行装填；然后拿到 5，临时码放到 6 上面；最后取了 4 号颜色直接装填；剩下的工作就是顺序从货架上取下 5、6、7 依次装填。</p><p>但如果工厂按照 3、1、5、4、2、6、7 这个顺序发货，工人就必须要愤怒地折腾货架了，因为装填完 2 号颜色以后，不把货架上的多个箱子搬下来就拿不到 3 号箱，就不可能顺利完成任务。</p><p>另外，货架的容量有限，如果要堆积的货物超过容量，工人也没办法顺利完成任务。例如工厂按照 7、6、5、4、3、2、1 这个顺序发货，如果货架够高，能码放 6 只箱子，那还是可以顺利完工的；但如果货架只能码放 5 只箱子，工人就又要愤怒了……</p><p>本题就请你判断一下，工厂的发货顺序能否让工人顺利完成任务。</p><h2 id="输入格式：-2"><a href="#输入格式：-2" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入首先在第一行给出 3 个正整数，分别是彩虹瓶的颜色数量 N（1&lt;N≤10^3）、临时货架的容量 M（&lt;N）、以及需要判断的发货顺序的数量 K。</p><p>随后 K 行，每行给出 N 个数字，是 1 到N 的一个排列，对应工厂的发货顺序。</p><p>一行中的数字都以空格分隔。</p><h2 id="输出格式：-2"><a href="#输出格式：-2" class="headerlink" title="输出格式："></a>输出格式：</h2><p>对每个发货顺序，如果工人可以愉快完工，就在一行中输出 YES；否则输出 NO。</p><h2 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h2><pre><code>7 5 37 6 1 3 2 5 43 1 5 4 2 6 77 6 5 4 3 2 1</code></pre><h2 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h2><pre><code>YESNONO</code></pre><p>思路：没啥好说的，直接读数，用一个stack模拟一下就行了。</p><pre><code>#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include&lt;stack&gt;#include&lt;cmath&gt;#include&lt;set&gt;#include&lt;string.h&gt;using namespace std;int main() {    int n, m, k;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for (int i = 0; i &lt; k; i++)    {        int a[1001];        for (int j = 0; j &lt; n; j++)            cin &gt;&gt; a[j];        stack&lt;int&gt; s;        int now = 1;        for (int j = 0; j &lt; n; j++)        {            if (a[j] == now)            {                now++;                if (s.empty())                    continue;                while (!s.empty())                {                    if (s.top() == now)                    {                        now++;                        s.pop();                    }                    else                        break;                }            }            else            {                s.push(a[j]);                if (s.size() &gt; m)                    break;            }        }        if (now == n + 1)            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;        else            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="oj" scheme="http://yoursite.com/categories/oj/"/>
    
    
      <category term="比赛" scheme="http://yoursite.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
      <category term="oj" scheme="http://yoursite.com/tags/oj/"/>
    
  </entry>
  
  <entry>
    <title>【Unity】自制unity3D弹幕游戏</title>
    <link href="http://yoursite.com/post/2cf7b827.html"/>
    <id>http://yoursite.com/post/2cf7b827.html</id>
    <published>2019-03-24T15:55:28.000Z</published>
    <updated>2019-12-29T10:08:00.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/3.jpg" alt="封面"><br>学校的Unity3D企业实习的作品，用了三天时间制作</p><h1 id="WSAD上下左右"><a href="#WSAD上下左右" class="headerlink" title="WSAD上下左右"></a>WSAD上下左右</h1><h1 id="J发射子弹，K大招（只能抵消敌方子弹而不会对地方造成伤害）"><a href="#J发射子弹，K大招（只能抵消敌方子弹而不会对地方造成伤害）" class="headerlink" title="J发射子弹，K大招（只能抵消敌方子弹而不会对地方造成伤害）"></a>J发射子弹，K大招（只能抵消敌方子弹而不会对地方造成伤害）</h1><h1 id="发射子弹过程中按L，可变集中火力形态，同时移动速度变慢，便于躲避子弹"><a href="#发射子弹过程中按L，可变集中火力形态，同时移动速度变慢，便于躲避子弹" class="headerlink" title="发射子弹过程中按L，可变集中火力形态，同时移动速度变慢，便于躲避子弹"></a>发射子弹过程中按L，可变集中火力形态，同时移动速度变慢，便于躲避子弹</h1><p>由于没有设置大招条件，所以可以无限发射大招，比较耍赖，所以为了证明自己的技术，最好不要用大招哦<br>玩家有20滴血，小怪有20滴血，BOSS有900滴血<br>打死小怪加10分，打死BOSS加45分，总分超过1500才能被称为大佬<br><img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"> <img src="/img/hj.png" alt="封面"></p><p><center>滑稽分界线</center><br><a href="https://yoyo-nb.github.io/DanmuGame/" title="DanmuGame" target="_blank" rel="noopener">点这里试玩点这里试玩点这里试玩</a>. </p><p>本垃圾试玩视频（在博客里只能360P垃圾画质，选择1080P画质会直接跳进bilibili观看）</p><iframe width="800" height="450" src="//player.bilibili.com/player.html?aid=45565323&cid=79783064&page=1" frameborder="0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="搞事" scheme="http://yoursite.com/categories/%E6%90%9E%E4%BA%8B/"/>
    
    
      <category term="Unity3D" scheme="http://yoursite.com/tags/Unity3D/"/>
    
      <category term="游戏" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>【算导】建堆过程时间复杂度分析</title>
    <link href="http://yoursite.com/post/d469f3ff.html"/>
    <id>http://yoursite.com/post/d469f3ff.html</id>
    <published>2019-03-18T06:45:04.000Z</published>
    <updated>2019-03-18T12:51:27.432Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下堆假设都是最大堆。<br>维护堆的性质的函数：将当前点与左右孩子比较，若孩子更大，将较大的孩子与当前节点交换位置，当前节点被换到的子节点继续用此方法，直到叶节点或不需要交换。<br>若共有n个元素，则每次调用该方法的时间复杂度为O(lgn)。建堆过程需要自底向上将所有元素都调用一遍该方法，看起来时间复杂度应为O(nlgn),但这个上界虽然正确，却不是渐进紧确的，有很大一部分的节点高度并没有达到lgn。</p><p>设n个元素，高度为lgn，堆中高度为h的元素最多有n/2^(h+1)个（h从0开始计数），高度为h的节点调用上述方法的时间复杂度为O（h），则总时间代价为：</p><script type="math/tex; mode=display">\sum_{h=0}^{\left \lfloor lgn \right \rfloor}\left \lceil \frac{n}{2^{h+1}} \right \rceil O(h) = O(n\sum_{h=0}^{\left \lfloor lgn \right \rfloor}\frac{h}{2^{h}})</script><p>等式右边由于在O（）内部，所以常数对结果没有影响，所以分母中2的幂数可以改变，变为2^h。根据级数：当|x|&lt;1时:</p><script type="math/tex; mode=display">\sum_{k=0}^{\infty }x^{k} = \frac{1}{1-x}</script><p>两边同时微分，并乘以x，得：</p><script type="math/tex; mode=display">\sum_{k=0}^{\infty }kx^{k} = \frac{x}{(1-x)^{2}}</script><p>将x等于1/2带入，结果为2。<br>则建堆过程的时间复杂度为</p><script type="math/tex; mode=display">O(n\sum_{h=0}^{\left \lfloor lgn \right \rfloor}\frac{h}{2^{h}}) = O(n\sum_{h=0}^{\infty }\frac{h}{2^{h}}) = O(2n) = O(n)</script><p>因此可以在线性时间内把一个无序数组构造成一个最大堆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法导论" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算导" scheme="http://yoursite.com/tags/IA/"/>
    
  </entry>
  
  <entry>
    <title>【算导】生日悖论</title>
    <link href="http://yoursite.com/post/81339208.html"/>
    <id>http://yoursite.com/post/81339208.html</id>
    <published>2019-03-18T03:54:31.000Z</published>
    <updated>2019-03-18T12:51:27.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>算导P73</p><h1 id="生日悖论"><a href="#生日悖论" class="headerlink" title="生日悖论"></a>生日悖论</h1><p>屋内有k个人，一年有n天，k达到多少时，两人生日相同的机会能达到50%？<br>至少两人生日相同概率等于1-都不相同概率<br>则k个人都不相同的事件：</p><script type="math/tex; mode=display">B_{k}=\bigcap_{i=1}^{k} A_{i}</script><p>其中，Ai为所有j&lt;i，i与j不同生日的事件。则：</p><script type="math/tex; mode=display">B_{k}=A_{k}\bigcap B_{k-1}</script><p>则有递归式：</p><script type="math/tex; mode=display">P(B_{k})=P(B_{k-1})P(A_{k}|B_{k-1})</script><p>即：假设1到k-1编号的人两两不相同，则1到k的人两两不相同的概率等于1到k-1两两不相同的概率乘以k号与前面所有人不相同的概率，取P(B1)=P(A1)=1<br>则可求P(Bk):<br>过程略（太麻烦了）<br>结果为：-k(k-1)/2n≤ln(1/2)时成立，解得当n=365时，k至少为23。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法导论" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算导" scheme="http://yoursite.com/tags/IA/"/>
    
  </entry>
  
  <entry>
    <title>【算导】分治法求解最大子数组</title>
    <link href="http://yoursite.com/post/35693.html"/>
    <id>http://yoursite.com/post/35693.html</id>
    <published>2019-03-15T16:00:33.000Z</published>
    <updated>2019-12-26T13:58:48.424Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>任意子数组必然是以下三种情况之一：</p><p>1.完全在a[low…mid]中。</p><p>2.完全在a[mid+1…high]中。</p><p>3.跨越了数组中点。</p><p>若结果为1或2，则可通过递归求解，若结果为3，则可通过一个线性时间复杂度的函数求解：</p><pre><code>FIND-CROSS(a,low,mid,high)    leftsum=0;    sum=0;    for(int i=mid;i&gt;=low;i--)    {        sum+=a[i];        leftsum=max(leftsum,sum);    }    rightsum=0;    sum=0;    for(int i=mid;i&lt;high;i++)    {        sum+=a[i];        rightsum=max(rightsum,sum);    }return leftsum+rightsum</code></pre><p>最后写一个总函数：</p><pre><code>FIND(a,low,high)    if(low==high)        return a[low]    else    {        mid=(low+high)/2        b=FIND(a,low,mid)        c=FIND(a,mid+1,high)        d=FIND-CROSS(a,low,mid,high)        return max(b,c,d);    }</code></pre><p>时间复杂度O(nlogn)</p><p>一个更优化的方法，时间复杂度O(n)<br>从头遍历，每遍历一个数，加到sum中，与当前最大值res比较更新res，当sum小于0时，sum、<br>等于0，相当于把之前的所有结果清零，从下一个数重新比较并继续更新res</p><pre><code>int maxSubArray(vector&lt;int&gt; nums) {    int ge = nums.size();    if (ge == 0)        return 0;    int sum = 0;    int res = nums[0];    for (int i = 0; i &lt; ge; i++)    {        sum += nums[i];        res = max(sum, res);        if (sum &lt; 0)            sum = 0;            }    return res;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="做题笔记" scheme="http://yoursite.com/categories/oj/"/>
    
    
      <category term="算导" scheme="http://yoursite.com/tags/IA/"/>
    
  </entry>
  
</feed>
